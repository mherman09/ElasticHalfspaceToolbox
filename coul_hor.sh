#!/bin/sh

###############################################################################
# Script for computing and plotting Coulomb stress changes on a horizontal
# surface generated by an earthquake in an elastic half-space.
###############################################################################

gmt set PS_MEDIA letter

if [ ! -f no_green_mwh.cpt ]; then
cat > no_green_mwh.cpt << EOF
# Color table using in Lab for Satellite Altimetry
# For folks who hate green in their color tables
# Designed by W.H.F. Smith, NOAA
# Modified to make small values white
-32	32/96/255	-28	32/96/255
-28	32/159/255	-24	32/159/255
-24	32/191/255	-20	32/191/255
-20	0/207/255	-16	0/207/255
-16	42/255/255	-12	42/255/255
-12	85/255/255	-8	85/255/255
-8	127/255/255	-3.2	127/255/255
-3.2	255/255/255	0	255/255/255
0	255/255/255	3.2	255/255/255
3.2	255/240/0	8	255/240/0
8	255/191/0	12	255/191/0
12	255/168/0	16	255/168/0
16	255/138/0	20	255/138/0
20	255/112/0	24	255/112/0
24	255/77/0	28	255/77/0
28	255/0/0		32	255/0/0
B	32/96/255
F	255/0/0
EOF
fi

###############################################################################
# The user can specify the following variables:
#  PSFILE   Name of the output PostScript file
#  NN       Density of the computation grid (NN x NN)
#  THR      Threshold value for slip in FFM (fraction of maximum slip)
###############################################################################

# Name of output PostScript file
PSFILE="coul_hor.ps"

# Coulomb stress grid is (NN x NN) points
NN="120"
#NN="50"

# Threshold percentage of peak slip in FFM to be retained
THR="0.15"

###############################################################################
#	PARSE COMMAND LINE TO GET SOURCE TYPE AND FILE NAME
###############################################################################

function USAGE() {
echo
echo "Usage: coul_hor.sh SRC_TYPE SRC_FILE [-Rw/e/s/n] [-Ts/d/r] [-Zdep] [-seg]"
echo "    SRC_TYPE     Either MT (moment tensor) or FFM (finite fault model)"
echo "    SRC_FILE     Name of input file"
echo "                   MT:  EVLO EVLA EVDP STR DIP RAK MAG"
echo "                   FFM: finite fault model in subfault format"
echo "    -Rw/e/s/n    Define map limits (optional)"
echo "    -Ts/d/r      Define target fault strike/dip/rake (optional)"
echo "    -Zdep        Define target fault depth (optional)"
echo "    -seg         Draw each fault segment (default draws as one segment)"
echo 
exit
}
# Check for minimum number of required arguments
if [ $# -lt 2 ]
then
    echo "!! Error: SRC_TYPE and SRC_FILE arguments required"
    echo "!!        Other arguments optional"
    USAGE
fi
SRC_TYPE="$1"
SRC_FILE="$2"
# Check that source type is correct
if [ $SRC_TYPE != "FFM" -a $SRC_TYPE != "MT" ]
then
    echo "!! Error: source type must be FFM or MT"
    USAGE
fi
# Check that input file exists
if [ ! -f $SRC_FILE ]
then
    echo "!! Error: no source file $SRC_FILE found"
    USAGE
fi
# Parse optional arguments
LIMS=""
TSTR=""
TDIP=""
TRAK=""
Z=""
SEG="0"
shift;shift
while [ "$1" != "" ]
do
    case $1 in
        -R*) LIMS="$1"
             ;;
        -T*) TSTR=`echo $1 | sed -e "s/-T//" | awk -F"/" '{print $1}'`
             TDIP=`echo $1 | sed -e "s/-T//" | awk -F"/" '{print $2}'`
             TRAK=`echo $1 | sed -e "s/-T//" | awk -F"/" '{print $3}'`
             ;;
        -Z*) Z=`echo $1 | sed -e "s/-Z//" | awk '{print $1}'`
             ;;
        -seg) SEG="1" ;;
          *) echo "!! Error: no option \"$1\""
             USAGE
             ;;
    esac
    shift
done

###############################################################################
###############################################################################
# Everything below this point should be automated. This script requires the
# tools O92UTIL, GRID, and FF2GMT from Matt's codes, and creates the figure
# using GMT 5 commands. All of the work is performed in the same directory
# that the script is run from.
###############################################################################
###############################################################################

#####
#       INPUT FILES FOR COULOMB STRESS CALCULATION
#####
if [ $SRC_TYPE == "FFM" ]
then
    # Copy FFM to new file name
    cp $SRC_FILE ./ffm.dat
    # Simplify FFM by removing slip smaller than minimum threshold
    # percentage of maximum slip (THR*MAXSLIP)
    MAXSLIP=`awk '{if(substr($1,1,1)!="#" && NF>3){print $4}}' ffm.dat |\
             gmtinfo -C -I0.01 | awk '{print $2}'`
    awk '{
      if (substr($1,1,1)!="#" && NF>3 && $4<'"$MAXSLIP"'*'"$THR"')
        {print $1,$2,$3,0,$5,$6,$7,$8,$9,$10,$11}
      else
        {print $0}
    }' ffm.dat > t
    mv t ffm.dat
else
    # Copy MT to new file name
    cp $SRC_FILE ./mt.dat
fi

# Elastic half-space properties
LAMDA="4e10" # Lame parameter
MU="4e10"    # Shear modulus
echo "Lame $LAMDA $MU" > haf.dat

# I am getting depth, strike, dip, rake directly from the FFM, by a weighted
# average of each value. The rake is set to either 0 or 180, assuming that
# the source event is a near-vertical strike-slip earthquake.
if [ $SRC_TYPE == "FFM" ]
then
    awk 'BEGIN{n=0;s=0;d=0;r=0;z=0;u=0}
         {u=$4;n=n+u;s=s+u*$6;d=d+u*$7;r=r+u*$5;z=z+u*$3}
         END{print z/n,s/n,d/n,r/n}' ffm.dat > junk
    if [ -z $Z ]
    then
        Z=`awk '{printf("%12.0f"),$1}' junk | awk '{print $1}'`
    else
        echo "Using source depth from command line: $Z"
    fi
    if [ -z $TRAK ]
    then
        TSTR=`awk '{printf("%12.0f"),$2}' junk | awk '{print $1}'`
        TDIP=`awk '{printf("%12.0f"),$3}' junk | awk '{print $1}'`
        TRAK=`awk '{printf("%12.0f"),$4}' junk | awk '{if(90<$1&&$1<270||$1<-90){print 180}else{print 0}}'`
        echo "Automatic target kinematics: $TSTR $TDIP $TRAK"
    else
        echo "Using target kinematics from command line: $TSTR $TDIP $TRAK"
    fi
    rm junk
else
    if [ -z $Z ]
    then
        Z=`awk '{print $3}' mt.dat`
    else
        echo "Using source depth from command line: $Z"
    fi
    if [ -z $TRAK ]
    then
        TSTR=`awk '{print $4}' mt.dat`
        TDIP=`awk '{print $5}' mt.dat`
        TRAK=`awk '{print $6}' mt.dat`
    else
        echo "Using target kinematics from command line: $TSTR $TDIP $TRAK"
    fi
fi
FRIC="0.4"
echo $TSTR $TDIP $TRAK $FRIC > trg.dat

#####
#       SET UP COMPUTATION GRID
#####
if [ -z $LIMS ]
then
    # Use "-auto" option in O92UTIL to get rough map limits
    D="10"  # Test grid increment is large, to get map limits
    ZT="10"
    if [ $SRC_TYPE == "FFM" ]
    then
        o92util -ffm ffm.dat -auto h $ZT $D -haf haf.dat -disp disp.out > auto.dat
    else
        o92util -mag mt.dat -auto h $ZT $D -haf haf.dat -disp disp.out > auto.dat
    fi
    rm autosta.dat
    W=`grep " W: " auto.dat | awk '{print $2}'`
    E=`grep " E: " auto.dat | awk '{print $2}'`
    S=`grep " S: " auto.dat | awk '{print $2}'`
    N=`grep " N: " auto.dat | awk '{print $2}'`
    echo "Starting map limits: $W $E $S $N"
    
    # Determine if map has decent aspect ratio and correct as necessary
    # Mercator projection x and y lengths
    X=`echo $W $E | awk '{print $2-$1}'`
    Y=`echo $S $N |\
       awk '{
         v2 = log(sin(3.14159/4+$2/2*0.01745)/cos(3.14159/4+$2/2*0.01745))
         v1 = log(sin(3.14159/4+$1/2*0.01745)/cos(3.14159/4+$1/2*0.01745))
         print v2-v1
       }' |\
       awk '{print $1/0.017}'`
    # Check map aspect ratio (no skinnier than 1.4:1)
    FIX=`echo $X $Y |\
         awk '{
           if ($1>1.4*$2) {print "fixx"}
           else if ($2>1.4*$1) {print "fixy"}
           else {print 1}
         }'`
    # Reduce map limits in long dimension
    if [ $FIX == "fixx" ]
    then
        NEW=`echo $W $E $Y | awk '{print 0.5*($1+$2)-$3*0.70,0.5*($1+$2)+$3*0.70}'`
        W=`echo $NEW | awk '{print $1}'`
        E=`echo $NEW | awk '{print $2}'`
    elif [ $FIX == "fixy" ]
    then
        NEW=`echo $S $N $X $Y |\
             awk '{print 0.5*($1+$2)-0.7*$3/$4*($2-$1),0.5*($1+$2)+0.7*$3/$4*($2-$1)}'`
        S=`echo $NEW | awk '{print $1}'`
        N=`echo $NEW | awk '{print $2}'`
    fi
    # Round map limits to nearest 0.1
    W=`echo "$W\n$E" | gmtinfo -C -I0.1 | awk '{print $1}'`
    E=`echo "$W\n$E" | gmtinfo -C -I0.1 | awk '{print $2}'`
    S=`echo "$S\n$N" | gmtinfo -C -I0.1 | awk '{print $1}'`
    N=`echo "$S\n$N" | gmtinfo -C -I0.1 | awk '{print $2}'`
    echo "Final map limits:    $W $E $S $N"
else
    W=`echo $LIMS | sed -e "s/\// /g" -e "s/-R//" | awk '{print $1}'`
    E=`echo $LIMS | sed -e "s/\// /g" -e "s/-R//" | awk '{print $2}'`
    S=`echo $LIMS | sed -e "s/\// /g" -e "s/-R//" | awk '{print $3}'`
    N=`echo $LIMS | sed -e "s/\// /g" -e "s/-R//" | awk '{print $4}'`
    echo "Using map limits from command line: $W $E $S $N"
fi

# Create (NN x NN) point horizontal grid
grid -x $W $E -nx $NN -y $S $N -ny $NN -z $Z -o sta.dat

#####
#	COMPUTE COULOMB STRESS CHANGE
#####
if [ $SRC_TYPE == "FFM" ]
then
    o92util -ffm ffm.dat -sta sta.dat -haf haf.dat -trg trg.dat -coul coul.out -prog
else
    o92util -mag mt.dat -sta sta.dat -haf haf.dat -trg trg.dat -coul coul.out -prog -gmt rect.out
fi

#####
#	PLOT RESULTS
#####
PORTRAIT=`echo $X $Y | awk '{if($1<$2){print "-P"}}'`
PROJ="-JM5i $PORTRAIT"
LIMS="-R$W/$E/$S/$N"

# Colored grid of Coulomb stress changes
gmt makecpt -T-1e5/1e5/1e4 -C./no_green_mwh.cpt -D > coul.cpt
gmt makecpt -T-1e-1/1e-1/1e-2 -C./no_green_mwh.cpt -D > coul2.cpt
awk '{print $1,$2,$4}' coul.out | gmt xyz2grd -Gcoul.grd $LIMS -I$NN+/$NN+
gmt grdimage coul.grd $PROJ $LIMS -Ccoul.cpt -Y1.5i -K > $PSFILE
gmt psscale -D2.5i/-0.8i/5.0i/0.2ih -Ccoul2.cpt -Ba0.05 -Bg0.01 \
    -B+l"Coulomb Stress Change (MPa)" -Al -K -O >> $PSFILE

# Map stuff
ANNOT=`echo $W $E | awk '{if($2-$1<=10){print 1}else{print 2}}'`
gmt psbasemap $PROJ $LIMS -Bxa${ANNOT} -Bya1 -BWeSn -K -O --MAP_FRAME_TYPE=plain >> $PSFILE
gmt pscoast $PROJ $LIMS -Dh -W1p -G205/205/205 -N1/0.5p -K -O -t85 >> $PSFILE

# Plot FFM slip contours
if [ $SRC_TYPE == "FFM" ]
then
    if [ $SEG -eq 0 ]
    then
        ff2gmt -f ffm.dat -slip slip.out -clip clip.out
    else
        ff2gmt -f ffm.dat -slip slip.out -clipseg clip.out
    fi
    MAXSLIP=`awk '{print $3}' slip.out | gmtinfo -C | awk '{print $2}'`
    CONT=`echo $MAXSLIP |\
          awk '{
            if ($1>=50) {print 10}
            else if ($1>=20) {print 5}
            else if ($1>=10) {print 2}
            else if ($1>=2) {print 1}
            else {print 0.5}
          }'`
    echo $CONT $MAXSLIP | awk '{for (i=$1;i<=$2;i=i+$1){print i,"C"}}' > junk
    awk '{print $1,$2,$3}' slip.out |\
        gmt surface -Gslip.grd -I0.10/0.10 -Tb1 -Ti0.25 $LIMS
    gmt psclip clip.out $PROJ $LIMS -K -O >> $PSFILE
    gmt grdcontour slip.grd $PROJ $LIMS -W1p,white -Cjunk -K -O -t40 >> $PSFILE
    gmt psclip -C -K -O >> $PSFILE
    gmt psxy clip.out $PROJ $LIMS -W1p,white -K -O -t40 >> $PSFILE
    rm junk
else
    awk '{print $1,$2,$4,$5,$6}' rect.out |\
        gmt psxy $PROJ $LIMS -SJ -W1p,white -K -O -t40 >> $PSFILE
fi

# Plot epicenter
if [ $SRC_TYPE == "FFM" ]
then
    LONX=`sed -n -e "3p" ffm.dat | sed -e "s/.*Lon:/Lon:/" | awk '{print $2}'`
    LATX=`sed -n -e "3p" ffm.dat | sed -e "s/.*Lon:/Lon:/" | awk '{print $4}'`
    echo $LONX $LATX |\
        gmt psxy $PROJ $LIMS -Sa0.15i -W1p,black -K -O  >> $PSFILE
fi

# Legend (all coordinates are in cm from the bottom left)
X1="0.2"
X2="3.0"
Y1="0.2"
Y2="3.5"
XM=`echo $X1 $X2 | awk '{print 0.5*($1+$2)}'`
gmt psxy -JX10c -R0/10/0/10 -W1p -Gwhite -K -O >> $PSFILE << EOF
$X1 $Y1
$X1 $Y2
$X2 $Y2
$X2 $Y1
$X1 $Y1
EOF
gmt pstext -JX10c -R0/10/0/10 -F+f+j -N -K -O >> $PSFILE << EOF
$XM 3.2 12,1 CM @_Target Faults@_
$XM 2.7 10,0 CM Strike/Dip/Rake
$XM 2.3 10,0 CM $TSTR\260/$TDIP\260/$TRAK\260
$XM 1.8 10,0 CM Depth: $Z km
EOF
if [ $SRC_TYPE == "FFM" ]
then
    echo $X2 $Y1 $CONT |\
        awk '{
          if($3==1) {print $1+0.2,$2,"10,2 LB FFM Slip Contours: "$3" meter"}
          else      {print $1+0.2,$2,"10,2 LB FFM Slip Contours: "$3" meters"}
        }' |\
        gmt pstext -JX10c -R0/10/0/10 -F+f+j -N -K -O >> $PSFILE
fi
# Schematic of target faults
XF="1.0"  # center of fault in x direction
YF="0.8"  # center of fault in y direction
LEN="1.0" # length of slip vector arrows
D="0.2"   # offset of slip vector arrows
FLT="0.8" # side length of square fault
SV=`echo $TSTR $TDIP $TRAK |\
    awk '{
      pi = 4*atan2(1,1)
      d2r = pi/180
      coss = cos((90-$1)*d2r)
      sins = sin((90-$1)*d2r)
      cosd = cos($2*d2r)
      sind = sin($2*d2r)
      cosr = cos($3*d2r)
      sinr = sin($3*d2r)
      x =  cosr*coss - sinr*cosd*sins
      y =  cosr*sins + sinr*cosd*coss
      z = sinr*sind
      print atan2(y,x)/d2r
    }'`
DX=`echo $TSTR $D | awk '{print $2*sin(($1+90)*0.01745)}'`
DY=`echo $TSTR $D | awk '{print $2*cos(($1+90)*0.01745)}'`
# Footwall slip vector
echo $DX $DY $SV $XF $YF $LEN |\
    awk '{print (-1)*$1+$4,(-1)*$2+$5,$3+180,$6}' |\
    gmt psxy -JX10c -R0/10/0/10 -Sv8p+e+jc+a45 -W1p -Gblack -K -O >> $PSFILE
# Fault square projected onto horizontal surface
echo $XF $YF $TSTR $FLT `echo $TDIP | awk '{print 0.7*cos($1*0.01745)}'` |\
    gmt psxy -JX10c -R0/10/0/10 -SJ -W1p,55/55/55 -Gwhite -K -O -t25 >> $PSFILE
# highlight updip edge of fault
echo $TSTR $TDIP $FLT $XF $YF |\
    awk '{
      d = $3*0.5
      print d*sin(($1-90)*0.01745)*cos($2*0.01745)+$4,
              d*cos(($1-90)*0.01745)*cos($2*0.01745)+$5,
                      $1,$3}' |\
    gmt psxy -JX10c -R0/10/0/10 -SV10p+jc -W2p,darkgreen -K -O -t25 >> $PSFILE
# Hanging wall slip vector
echo $DX $DY $SV $XF $YF $LEN |\
    awk '{print $1+$4,$2+$5,$3,$6}' |\
    gmt psxy -JX10c -R0/10/0/10 -Sv8p+e+jc+a45 -W1p -Gblack -K -O >> $PSFILE

# Beachball
XF="2.3"
TRAK=`echo $TRAK | awk '{if($1==0){print 0.1}else{print $1}}'`
echo $XF $YF 5 $TSTR $TDIP $TRAK 5 |\
    gmt psmeca -JX10c -R0/10/0/10 -Sa${FLT}c -G155/155/155 -K -O >> $PSFILE

echo 0 0 | gmt psxy $PROJ $LIMS -O >> $PSFILE


#####
#	CLEAN UP
#####
ps2pdf $PSFILE
rm no_green_mwh.cpt

